  ### 朴素解法
  * 找下一个排列的数。大家可以先想想大脑来是怎么完成这个找数的过程的。

    * 我们会尽可能的将低位的数字变大，这样才符合「下一个排列」的定义。

    * 也就是从低位往高位检查，观察某一位在「下一个排列」中是否可以被更大的数代替。

* 那么如何判断某一位能够被更大的数代替呢？

    * 其实就是将 k 位到低位的所有数作为候选，判断是否有更大的数可以填入 k 位中。

    * 假设当前我们检查到 k 位，要分析第 k 位在「下一个排列」中是否能被更大的数代替。

    * 我们会先假定高位到 k 位的数不变，在 k 位到低位中是否有比 k 位上的数更大的数，如果有说明 k 在「下一个排列」中变大。

    * 换句话说，我们要找的第 k 位其实就是从低位到高位的第一个下降的数。

    * 为了更好理解，我们结合样例来分析，假设样例为 [1,3,5,4,1]：

* 从后往前找，找到第一个下降的位置，记为 k。注意k 以后的位置是降序的。 在样例中就是找到 3

* 从 k 往后找，找到最小的比 k 要大的数。 找到 4

* 将两者交换。注意此时 k 以后的位置仍然是降序的。

* 直接将 k 以后的部分翻转（变为升序）。

* 注意：如果在步骤 1 中找到头部还没找到，说明该序列已经是字典序最大的排列。按照题意，我们要将数组重新排列成最小的排列。

![20210728193223](https://i.loli.net/2021/07/29/OqE9S8UrBXoP4Ne.png)

![20210728193237](https://i.loli.net/2021/07/29/3hOxePakbNCB4HM.png)

![20210728193246](https://i.loli.net/2021/07/29/lNzr45OJnpMdA71.png)

![20210728193301](https://i.loli.net/2021/07/29/yKnF5XOjCW9iN2P.png)

![20210728193308](https://i.loli.net/2021/07/29/RMdPOBfKDQrWEU2.png)

![20210728193315](https://i.loli.net/2021/07/29/MV3jr12TQ6KNF4t.png)

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int n = nums.length;
        int k = n - 1;
        while (k - 1 >= 0 && nums[k - 1] >= nums[k]) k--;
        if (k == 0) {
            reverse(nums, 0, n - 1);
        } else {
            int u = k;
            while (u + 1 < n && nums[u + 1] > nums[k - 1]) u++;
            swap(nums, k - 1, u);
            reverse(nums, k, n - 1);
        }
    }
    void reverse(int[] nums, int a, int b) {
        int l = a, r = b;
        while (l < r) {
            swap(nums, l++, r--);
        }
    }
    void swap(int[] nums, int a, int b) {
        int c = nums[a];
        nums[a] = nums[b];
        nums[b] = c;
    }
}
```
![20210728194413](https://i.loli.net/2021/07/29/eMqoctiJhnVE3HU.png)