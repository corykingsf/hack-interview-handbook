
- comparison based sort
 - O(nlogn) * O(compare())


- non-comparison based sort
    - bucket  sort:  知道了要排序的数的数值范围，可以把他们分成一个bucket一个bucket
    - count sort: 


- priorityQueue也是一种partial sort, quickselect也是一种partial sort


![picture 1](https://i.loli.net/2021/09/14/XirfycxMCVjhm28.png)  


- merge sort的变种timsort

- quick sort的实际运行时间更短，compresion更少，整个程序的locality更好，做partition能更好的用到cpu和cache, sort primitive的时候用quick sort


- selection和insertion sort适用于element数量较少的时候，避免用recursion(merge sort, quick sort)

- input size在20以内，我们用selection sort效率最高

- n比较小的时候看常数，如果常数较大，可能n^2的算法更好




- java中的Comparator是个interface, java之前不能把函数作为参数，所以只能传一个object进去，用到的其实是这个object的compare方法


### 是否有很多重复元素 ==》 三路快排

### 是否大部分数据距离它正确的位置很近，是否近乎有序 ==> 插入排序

### 是否数据的取值范围非常有限，比如对学生成绩排序 ==> 计数排序


### 对排序有什么额外的要求: 是否需要稳定排序? 如果是的话，merge sort
### 数据的存储状况是怎样的？ 是否使用链表存储，如果是的话，归并排序是更好的选择
### 数据的大小是否可以装载进内存？如果数据量很大，或者内存很小，不足以装载在内存里，需要使用外排序算法

