-  51 N皇后
     - 暴力搜索题, 主要是判断一下行上，列上， diagonal, reverse diagonal上的conflict来决定能不能放
     - 重点：  
         - diagonal, reverse diagonal上元素坐标的特点
         - 把每行，每列，每个diagonal, 每个reverse diagonal上放过的元素存到hashmap,  bool数组， bit(所谓的状态压缩)上


![picture 1](https://i.loli.net/2021/09/30/hdmnWtQDXCYw5PR.png)  

```java
class Solution {
    boolean[] usedCols;
    boolean[] usedDiag; // 2*n-1條對角線
    boolean[] usedRevDiag;
    
    public List<List<String>> solveNQueens(int n) {
        usedCols = new boolean[n];
        usedDiag = new boolean[2*n-1]; // 2*n-1條對角線
        usedRevDiag = new boolean[2*n-1];  // 2*n-1條反對角線
        
        // n行n列，recursion tree有n層，每層決定一行，每行有N种可能
        
        List<List<String>> ret = new ArrayList<>();
        
        int[] board = new int[n]; // 表示一種方法
        dfs(ret, board, 0, n);  //從第0行開始
        return ret;
    }
    private void dfs(List<List<String>> ret, int[] board, int row, int n) {
        // base case
        if (row == n) {  //最後一行都已經放完了
           ret.add(toList(board));
            return;
        }
        // 依次try當前行的所有列
        for (int col = 0; col < n; col++) {
            // 確定當前列是否可以放棋子
            // check一個十字和兩個對角線的方向
            if (usedCols[col] || usedDiag[col +row] || usedRevDiag[col - row + n - 1]) continue;
            
            usedCols[col] = true;
            usedDiag[col + row] = true;
            usedRevDiag[col - row + n - 1] = true;
            
            board[row] = col;  //把棋子放在第col列
            dfs(ret, board, row + 1, n);
            // backtrack
            usedCols[col] = false;
            usedDiag[col + row] = false;
            usedRevDiag[col - row + n - 1] = false;
            
        }
    }
    private List<String> toList(int[] board) {
        List<String> ret = new ArrayList<>();
        int n = board.length;
        
        for (int i = 0; i < n; i++) {
            String curRow = "";
            for (int j = 0; j < n; j++) {
                if (j == board[i]) { curRow += "Q";
                 } else {
                   curRow += ".";
                }
            }
            ret.add(curRow);
        }
        return ret;
    }
}
```


- 52 N皇后 II
  - 只需要求出方案数
  - 跟51是同一道题

```java
class Solution {
    boolean[] cols;
    boolean[] diag;
    boolean[] revDiag;
    
    public int totalNQueens(int n) {
        cols = new boolean[n];
        diag = new boolean[2 * n - 1];
        revDiag = new boolean[2 * n - 1];
        
        // 只用求方案个数
        return dfs(0, n);
    }
    private int dfs(int curRow, int n) {
        if (curRow >= n) {
            return 1; //找到了其中一种放的方案
        }
        int ret = 0;
        for (int col = 0; col < n; col++) {
            if (cols[col] || diag[col + curRow] || revDiag[col - curRow + n - 1] ) continue;
            
            cols[col] = true;
            diag[col + curRow] = true;
            revDiag[col - curRow + n - 1] = true;
            
            ret += dfs(curRow + 1, n);
            cols[col] = false;
            diag[col + curRow] = false;
            revDiag[col - curRow + n - 1] = false;
        }
        return ret;
    }
}
```