1 Two sum
-
- solution 1: scan from left to right, use hashmap记住之前遍历过的数字

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        // brute force
        if (nums == null || nums.length == 0) return new int[]{-1, -1};
        
        for (int i = 1; i < nums.length ;i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] + nums[j] == target) return new int[]{j, i};
            }
        }
        return new int[]{-1, -1};
    }
}
```
- solution 2: sort then apply two pointers,但是这题要返回下标，sort之后会把下标打乱






- 37. 解数独
  - 暴力搜索题, 主要是判断一下行上，列上， subgrid上的conflict来决定能不能放
  - 重点：  
    - subgrid上的状态怎么存
    - 把每行，每列，每个subgrid放过的元素存到hashmap,  bool数组， bitset上