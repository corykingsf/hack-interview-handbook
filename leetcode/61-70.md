


68 文本左右对齐
-

- 字符串大模拟，分情况讨论即可：
  - 如果当前行只有一个单词，特殊处理为左对齐；
  - 如果当前行为最后一行，特殊处理为左对齐；
  - 其余为一般情况，分别计算「当前行单词总长度」、「当前行空格总长度」和「往下取整后的单位空格长度」，然后依次进行拼接。当空格无法均分时，每次往靠左的间隙多添加一个空格，直到剩余的空格能够被后面的间隙所均分。


- 一行一行处理，每次先求出这一行最多可以放多少个单词，然后分三种情况处理：

- 如果是最后一行，则只实现左对齐：每个单词之间插入一个空格，行尾插入若干空格，使这一行的总长度是 maxWidth；
- 如果这一行只有一个单词，则直接在行尾补上空格；
- 其他情况，则需计算总共要填补多少空格，然后按题意均分在单词之间；
- 时间复杂度分析：每个单词只会遍历一遍，所以总时间复杂度是 O(n)。


```java
class Solution {
    static String get(int x)
    {
        String res = "";
        for(int i = 0;i < x;i ++) res += " ";
        return res;
    }
    public List<String> fullJustify(String[] words, int maxWidth) {
        List<String> ans = new ArrayList<String>();
        int n = words.length;
        for(int i = 0;i < n;i ++)  {
            int len = words[i].length();
            int j = i + 1;
            while(j < n && len + 1 + words[j].length() <= maxWidth) 
                len = len + 1 + words[j ++].length();

            String line = "";
            //如果是最后一行 或者 当前行只有一个单词，向左对齐
            if(j == n || j == i + 1) {
                line += words[i];
                for(int k = i + 1;k < j;k ++) line += " " + words[k];
                while(line.length() < maxWidth) line += " ";
            }  else   { //其余的左右对齐
           
                int cnt = j - i - 1;//空隙数
                int res = maxWidth - (len - cnt); // 空格数
                //将空格数分成cnt份
                int a = res / cnt ;//基本份
                int b = res % cnt ;//多余份
                line += words[i];
                for(int k = i + 1;k < j;k ++)
                {
                    if(b -- > 0) line += get(a + 1) + words[k];
                    else line += get(a) + words[k];
                }
            }

            ans.add(line);
            i = j - 1;
        }
        return ans;
    }
}
```