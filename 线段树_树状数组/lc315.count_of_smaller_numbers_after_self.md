
计算右侧小于当前元素的个数的六种方法：


这道题要用排序的思路来解决。快速查找和更新，使用递归或树的结构可以高效实现。


1.暴力模拟法，每次都从末尾找比nums[i]小的数并计数，然后放到结果数组即可.时间复杂度: O(n^2),leetcode上超时了

```java
    public List<Integer> countSmaller(int[] nums) {
        // sanity check
        List<Integer> smallerThanSelf = new ArrayList<>();

        for (int i = 0 ; i < nums.length - 1; i++) {
            int count = 0;
            for (int j = i +1; j < nums.length; j++) {
                if (nums[j] < nums[i]) {
                    count++;
                }
            }
            smallerThanSelf.add(count);
        }
        smallerThanSelf.add(0);
        return smallerThanSelf;
    }
```

2.插入排序 
从右往左插入排序，根据插入的位置计算右边小于当前元素的个数
优化：先使用二分查找位置，在插入，可以降低内层循环查找的时间复杂度O(nlogn),但是元素交换的次数还是O(^2)

3.记忆化+排序


4.树状数组
//1.某个位置加上一个数
//2.求1~x的和

求比x小的数的个数其实就是求11~(x-1)的数的个数 （假设所有数从1开始），在树上query一下(x-1)即可






