anagram:  同构异型体


fix sized sliding window

s: left border
f : right border

hashmap:  存a[s..f]每一个字母出现的频率
hashmap2: 存target string里每一个字母出现的频率


initialize: 
s = 0
f = n - 1
hashmap = {前4个字母和它们出现的频率}


in each step: 
step 1: hashmap == hashmap2  output
step 2: s++, f++, update hashmap, hashmap.add(a[f]), hashmap.remove(a[s-1])


hashmap.put(hashmap.getOrDefault(a[f], 0) + 1)

s = 0, f = 4
hashmap 
s = 1, f = 5

改进：  
这个hashmap的比较能做的更快，每次窗口滑动的时候，只会吃一个吐一个， 其实我们不用进行整个hashmap的比较
加一个变量记录窗口的状态

fix sized sliding window

s: left border
f : right border

hashmap:  存a[s..f]每一个字母出现的频率
hashmap2: 存target string里每一个字母出现的频率
### how  many characters in hashmap2 have the correct frequency

initialize: 
s = 0
f = n -1
hashmap = {<a,0>, <b,0>, <c,0>}
num_matches = 0

in each step:
step 1: if num_matches == mashmap2.size() output
step 2: s++, f++, hashmap.add(a[f]), hashmap.remove(a[s-1])
    s++
    f++
    if a[f] in s2:  
         hashmap[a[f]]++
         //a[f]的新的频率对上
         if hashmap[a[f]] == hashmap2[a[f]] : num_matches++
         //a[f]的旧的频率对上
         if hashmap[a[f]] - 1 == hashmap2[a[f]] : num_matches--
    if a[s-1] in s2:
        hashmap[a[s-1]]--

time = O(m)
space = O(m)


```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> ret = new ArrayList<>();
        if (s == null || s.length() == 0) return ret;
        
        if (p.length() > s.length()) return ret;
        
        Map<Character, Integer> map = counterMap(p);
        int match = 0;  // how many characters are matched in current window
        
        for (int i = 0; i < s.length(); i++) {
            char tmp = s.charAt(i);
            
            Integer count = map.get(tmp);
            
            if (count != null) {  //不在 target map里的不用管
                map.put(tmp, count - 1);
                if (count == 1) match++;
            }
            // remove slow
            if (i >= p.length()) {
                tmp = s.charAt(i - p.length());
                count = map.get(tmp);
                
                if (count != null) { // 不在target map里的不用管
                    map.put(tmp, count + 1);
                    if (count == 0) {
                        match--;
                    }
                }
            }
            if (match == map.size()) {
                ret.add(i - p.length() + 1);
            }
        }
        return ret;
    }
    private Map<Character, Integer> counterMap(String s) {
        Map<Character, Integer> map = new HashMap<>();
        for (char ch :s.toCharArray()) {
            Integer count = map.get(ch);
            if (count == null) {
                map.put(ch, 1);
            } else {
                map.put(ch, count + 1);
            }
        }
        return map;
    }
}

```

