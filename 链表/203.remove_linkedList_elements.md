递归

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null) {
            return null;
        }
        ListNode newHead = removeElements(head.next, val);
        if (head.val == val) {
            return newHead;
        
        } else {
            head.next = newHead;
            return head;
        }
    }
}
```

迭代的解法:


1. 用dummy node




2.不用dummy node

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //如果头节点需要删除,删除了之后新的头节点如果还等于val再删除
        while (head != null && head.val == val) {//因为要删除多个元素，所以要使用循环
            ListNode delNode = head;
            head = head.next;
            delNode.next = null;
        }
  
  
        if (head == null) return head; //如果链表中所有的节点都等于val,循环结束只后链表倍山空了，直接返回
        ListNode prev = head;
  
        while (prev.next != null) {
            //看看prev的下一个节点是不是要被删除
            if (prev.next.val == val) {  //为什么这里prev没向后挪一个，因为删除了原来的prev.next之后新的Prev.next有可能也是一个待删除节点，不能挪Prev否则跳过了要检查新节点
                ListNode delNode = prev.next;
                prev.next = delNode.next;
                delNode.next = null;
            } else {prev = prev.next;}
        }
        return head;
    }
}
```
