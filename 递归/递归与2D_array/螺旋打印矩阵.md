
一圈一圈的做recursion
每层recursion打一圈


![picture 2](https://i.loli.net/2021/09/16/YPOq2pMjv3hbVlg.png)  


![picture 3](https://i.loli.net/2021/09/16/Li2EoTc7BXPlhbs.png)  


两种遍历策略:
![picture 4](https://i.loli.net/2021/09/16/qbTIXGfV8Sscznt.png)  



- 如果一条边从头遍历到底，则下一条边遍历的起点随之变化

- 选择不遍历到底，可以减小横向、竖向遍历之间的影响

- 一轮迭代结束时，4条边的两端同时收窄 1

- 一轮迭代所做的事情变得很清晰：遍历一个“圈”，遍历的范围收缩为内圈

- 一层层向里处理，按顺时针依次遍历：上、右、下、左。

- 不再形成“环”了，就会剩下一行或一列，然后单独判断


- 四个边界：
  - 上边界 top:0
  - 下边界: botttom: matrix.length - 1
  - 左边界: left ： 0
  - 右边界 right: matrix[0].length - 1

- 矩阵不一定是方阵
    - top < bottom && left < right是循环的条件
    - 无法构成环了，就退出循环，退出时可能是这3种情况之一:
      - top == bottom && left < right  --- 剩一行
      - top < bottom && left == right  -- 剩一列
      - top == bottom && left == right -- 剩一项 (也是一行/列)
- 处理剩下的单行或单列
  - 因为是按顺时针推入结果数组的，所以
  - 剩下的一行，从左至右依次推入结果数组
  - 剩下的一列，从上至下依次推入结果数组
  
- 复杂度
  - 每个元素访问一次，时间复杂度m*n, m,n分别是矩阵的行数和列数
  - 空间复杂度m*n




 