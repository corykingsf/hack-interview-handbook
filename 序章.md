# hack-interview-handbook
背诵模板，背诵模型， 不是背诵解法
背模板很重要，作用跟背单词一样，少走很多弯路


有用的常数：  log(1m) 约等于 20
2^10= k
2^20 = M = 1048576 byte
2^30 = T
2^40 = P


### clarification:  读多还是写多啊， 与面试官沟通具体的需求，比如方法被调用的频率，再来进行数据结构的设计


数据范围：
n <= 20 暴力搜索
n  <= 1000   n^2 dp
 n <= 100   n^3 dp

 n  <= 10000, 100000  time= nlogn
 n <= 1m   time=o(n)



 有trie树的话字典可以不通过hashset给出

 



![20210817141842](https://i.loli.net/2021/08/18/e4tHfjXTYRkgDZc.png)

![20210814001029](https://i.loli.net/2021/08/14/D9Ps6GEFxBOLMlV.png)

![20210813233840](https://i.loli.net/2021/08/14/oY8fulGpHFDRxEq.png)
### debug技巧： 使用小的use case开始debug


线性结构： 数组，栈，队列，链表，哈希表
树结构： 二叉树，二分搜索树，AVL, 红黑树，Treap, splay, 堆，trie, 线段树， K-D树，并查集，哈弗曼树
图结构：邻接矩阵，邻接表

数据库使用的平衡数据结构：数结构： AVL, 红黑树，Treap, 伸展数，B树
数据结构还会使用哈希表

系统栈

优先对列： 堆 (os中使用堆快速在多任务中比较优先级并进行切换)

文件压缩：哈弗曼树

PDA通讯录： 线性结构链表性能低如何解决？ 使用trie

寻路算法： DFS, BFS


图论：最小生成树，最短路径，最大连通分量

线段树，union find, Trie现在面试也考的很多

![20210813225701](https://i.loli.net/2021/08/14/MAjoL3mWpXGiqyB.png)

```
用 T 函数表示法计算时间复杂度
T 函数推导法
我们介绍一种时间复杂度的推导方法：T函数推导法
比如二分法。二分法是每次通过 O(1) 的时间将规模为 n 的问题降低为规模为 n/2的问题。
这里我们用 T(n) 来表示规模为 n 的问题在该算法下的时间复杂度，那么我们得出推导公式：

T(n) = T(n/2) + O(1)

我们来逐个说明一下这个公式的意义。

首先 T 代表的是 Time Complexity,n 代表的是问题规模（二分法里就是数组的大小）。
那么 T(n) 代表的就是：求处理问题规模为n的数据的时间复杂度是多少。注意这里是一个问句，不是一个答案。
T(n) 根据算法的不同可以是O(n), 也可以是 O(nlogn)或任何值，而 O(n) 就是 O(n)。

然后 O 代表的是时间复杂度。O(1) 就意味着，你大概用一个 if 语句，或者简单的加加减减，就可以完成。O 在这里的意思是数量级约等于。在 O 的世界里，我们只考虑最高项是什么，不考虑系数和常数项。比如：


O(100n) = O(n)
O(n^2 + n) = O(n^2)
O(2^n + n^2 + 10) = O(2^n)
如何推导 T 函数
我们可以使用不断展开的方法进行推导：

T(n) = T(n/2) + O(1)
     = T(n/4) + O(1) + O(1)
     = T(n/8) + O(1) * 3
     = T(n/16) + O(1) * 4
     ...
     = T(1) + O(1) * logn
     = O(logn)

在时间复杂度的领域里，有如下的一些性质：

T(1) = O(1)// 解决规模为1的问题通常时间复杂度为O(1)。这个不100%对，但是99.9%的情况下都是如此。
k * O(n) = O(kn)
O(n) + O(m) = O(n + m)
上面的方法，是采用 T 函数展开的方法，将二分法的时间复杂度最终用 O(...) 来表示

那我们了解时间复杂度有什么用呢？在做题过程中，如果知道题目的数据范围，我们可以通过数据范围估算时间复杂度，再根据时间复杂度估计算法。
算法中，常见的时间复杂度有：

复杂度	可能对应的语法	备注
O(1)	位运算	常数级复杂度，一般面试中不会有
O(logn)	二分法，倍增法，快速幂算法，辗转相除法	
O(n)	枚举法，双指针算法，单调栈算法，KMP算法，Rabin Karp，Manacher's Algorithm	又称作线性时间复杂度
O(nlogn)	快速排序，归并排序，堆排序	
O(n^2)	枚举法，动态规划，Dijkstra	
O(n^3)	枚举法，动态规划，Floyd	
O(2^n)	与组合有关的搜索问题	
O(n!)	与排列有关的搜索问题	
在面试中，经常会涉及到时间复杂度的计算。当你在对于一个问题给出一种解法之后，面试官常会进一步询问，是否有更优的方法。此时就是在问你是否有时间复杂度
更小的方法（有的时候也要考虑空间复杂度更小的方法），这个时候需要你对常用的数据结构操作和算法的时间复杂度有清晰的认识，从而分析出可优化的部分，给出更优的算法。

例如，给定一个已经排序的数组，现在有多次询问，每次询问一个数字是否在这个数组中，返回True or False.

方法1： 每次扫描一遍数组，查看是否存在。
这个方法，每次查询的时间复杂度是: O(n)。

方法2：由于已经有序，可以使用二分查找的方法。
这个方法，每次查询的时间复杂度是: O(logn)。

方法3：将数组中的数存入Hashset。
这个方法，每次查询的时间复杂度是: O(1)。

可以看到，上述的三种方法是递进的，时间复杂度越来越小。

在面试中还有很多常见常用的方法，他们的时间复杂度并不是固定的，都需要掌握其时间复杂度的分析，要能够根据算法过程自己推算出时间复杂度。

```

```java  
// pure recursion模板
/*
判断当前情况是否非法，如果非法就立即返回，这一步也被称为完整性检查（Sanity Check）。例如，看看当前处理的情况是否越界，是否出现了不满足条件的情况。通常，这一部分代码都是写在最前面的。
判断是否满足结束递归的条件。在这一步当中，处理的基本上都是一些推导过程当中所定义的初始情况。
将问题的规模缩小，递归调用。在归并排序和快速排序中，我们将问题的规模缩小了一半，而在汉诺塔和解码（LeetCode91题）的例子中，我们将问题的规模缩小了一个。
利用在小规模问题中的答案，结合当前的数据进行整合，得出最终的答案。
*/
function fn(n) {
    // 第一步：判断输入或者状态是否非法？
    if (input/state is invalid) {
        return;
    }

    // 第二步：判读递归是否应当结束?
    if (match condition) {
        return some value;
    }

    // 第三步：缩小问题规模
    result1 = fn(n1)
    result2 = fn(n2)
    ...

    // 第四步: 整合结果
    return combine(result1, result2)

```


```python
# 回溯问题模板
def dfs(n){                         //可以描述阶段的状态
	if(valid) {收集结果，返回}	        //出口条件
	if(pruning) return;             //剪枝，这一步是为了加快回溯过程，降低程序执行时间
	for(i:1~p){                      //选择该阶段的所有决策
		选择可行决策;                   //剪枝的一种 
		add;						  //标记已访问该点
		DFS(n+1);                     //进入下一阶段
		recover;                      //还原
	}
}

```

对所有解进行分类，每类对应一个subproblem

## backtracking和pure recursion的联系： dfs backtracking每一层做一个什么选择，所有dfs都是求所有解的问题，每一层干什么事代表对所有解的一种分类的方法，当前层有多少种选择，有多少种选择就可以分成多少类，每一类都对应一个subproblem解决完之后的结果，

### dp可以求所有解，也可以求所有解的特征值/统计值，如果是求特征值/统计值,dp可以优化时间复杂度comparing to 暴力搜索.

### 从brute force开始优化的出发点是对所有解进行分类，分类就必须找到分类的基准，LIS这类题都是ending index分类(必须包括ending index)

### subsequence与subset是一类问题

### pure recursion里一个变量对应一个input,这个Input一定有大小的关系

人生路上，我们会遇到很多的坎。跨过去，你就可以成长，跨不过去就是困难和停滞。而在 后面很长的一段时间里，你都需要为这个困难买单。对于我们技术人来说，更是这样。既然 数据结构和算法这个坎，我们总归是要 跨过去，为什么不是现在呢 

						
高手之间的竞争在于细节. 这些细节包括:你用的算法是不是够优化，数据存 取的效率是不是够高，内存是不是够节省等等。这些累积起来，决定了一个框架是不是优 秀 

			
作为业务开发，我们会用到各种框架、中间件和底层系统，比如 Spring、RPC 框架、消息 中间件、Redis 等等。在这些基础框架中，一般都揉和了很多基础数据结构和算法的设计思 想。比如，我们常用的 Key-Value 数据库 Redis 中，里面的有序集合是用什么数据结构来实现 的呢?为什么要用跳表来实现呢?为什么不用二叉树呢? 
				 	 	 							
						
在平时的工作中，数据结构和算法的应用到处可见。我来举一个你非常熟悉的例子:如何实 时地统计业务接口的 99% 响应时间? 你可能最先想到，每次查询时，从小到大排序所有的响应时间，如果总共有 1200 个数据， 那第 1188 个数据就是 99% 的响应时间。很显然，每次用这个方法查询的话都要排序，效 率是非常低的。但是，如果你知道“堆”这个数据结构，用两个堆可以非常高效地解决这个问题.举一个例子 你写了一个接口 每天有成千上万的访问 你如何知道这个接口够不够快?响 应时间是1s还是5s?如何统计度量?用平均值?显然不是太适合?那用什么值来统计度量呢?你 可以自己搜索研究下 

coding:主体框架与细节分开
代码outstanding: 预判

### 练习反向思维，正着不行反着来,几个例子：
- lc695.岛屿的最大面积 --> 内陆湖也算在岛内呢?
- lc1499.满足不等式的最大值

![alt txt](https://raw.githubusercontent.com/corykingsf/hack-system-design-pixel/main/imgSnipaste_2021-06-22_22-21-29.png)


![alt txt](https://raw.githubusercontent.com/corykingsf/hack-system-design-pixel/main/imgSnipaste_2021-06-22_22-22-06.png)
#### 面试之后如何复盘
![alt txt](https://raw.githubusercontent.com/corykingsf/hack-system-design-pixel/main/imgSnipaste_2021-06-22_22-22-54.png)
##### 2-3 solid, 1-2 个border-line就可以过hc
##### 完整实现，自我检查，代码风格统一

##### 每个方格里面符合两个，就符合

target
easy:5mins
medium:15-20mins
hard:20-30mins

### "三刷五步"
初学建议分类刷 ->后期建议综合刷

一刷：每个小类别的代表性题目，各刷几道
此时如果需要看题解，很正常


二刷：
复习代表性题目
小类别合成大类别，刷改分类更多的题目，举一反三，在尽量少的提示下完成


三刷：
综合性题目，尽量独立实现+测试

![alt txt](https://raw.githubusercontent.com/corykingsf/hack-system-design-pixel/main/imgSnipaste_2021-06-22_22-09-58.png)

### 五步训练法是针对算法面试的评测点对口设计的:

### 如何做题： //从模型出发
- 第一步 理解体面
  - 想一想更多的例子和测试数据，看看有没有遗漏的地方
  - 提炼题目中的关键信息、变化信息
  - 面试的时候，跟面试官确认自己的理解,clarifcation: input是否有序？
  - 
- 第二步 部分实现
- 无论什么题目，先尝试实现一个朴素解法(比如搜索) // 暴力解只花2-3分钟propose, 问问题是不会扣分的
- 或者是部分场景下的解法
- 尽量让自己的解法更优，覆盖更多的场景
- 

 - 第三步 有提示解答
  - 看提示 != 看题解
  - 可以看题解的一部分，试试能否找到突破口
  - 例如题目类别，题解标题，时间复杂度，一个小结论
  - 面试是一个交互的过程，你可以与面试官交流获取适当的提示
  - 要能明白面试官在引导你什么，这就要从平时练起
 - 

- 第四步 独立解答
- 独立完成求解，同时注意测试
- 初期训练是通常可以都从第二步的搜索出发
  - 搜索时关注了哪些信息？
  - 他们有没有冗余？能不能更好的维护？
  - ‘有没有同类的子问题，找同类子问题去分支或动规


- 第五步 写题解
- 鼓励大家写题解
  - 尝试给别人讲(面试的时候也是要讲的)，尝试分析对比各种不同的解法
  - 题解也可以写成日记的形式，记录自己遇到的难点
  - 有助于加深自己的理解，以后也可以回看自己的题解，快速复习

### 训练两各方面：
- 一道题的思路是如何形成的，如何想到的，构建思维体系
- coding能力只需要一个月：目标：思路有了，代码就能落地

### 时间复杂度的logn为什么没有底数？  log以2为底, 通过换底公式，可以除一个常数，在底数不一样的对数之间变换，复杂度里常数是忽略的，所以没有底数


![alt txt](https://raw.githubusercontent.com/corykingsf/hack-system-design-pixel/main/imgSnipaste_2021-06-22_22-03-59.png)



均摊时间复杂度

![alt txt](https://raw.githubusercontent.com/corykingsf/hack-system-design-pixel/main/imgSnipaste_2021-06-23_00-03-57.png)

linux 默认系统栈只有8M
堆基本上跟内存大小同级


### 数据驱动算法
- 先学线性数据结构,然后学习其上各种灵活的算法
- 了解树，图等结果，然后学习递归、搜索等算法
- 形成集合、维度、状态空间等概念，然后学习动态规划等高级算法

- 抛开数据的支持，算法是假大空
- 脑子里有了数据结构的具体形状，算法将会更加形象，容易理解

### 知识框架
## 三条主线 +两个副本

三条主线
### 线性结构线
- 数组、链表、栈、队列 --> 前缀和、差分、双指针、滑动窗  -->哈希、集合、映射 ->字符串


### 树形结构线
- 递归、分治 -> 树与图 ->搜索  ->堆、二叉搜索树  ->字典树、并查集  -> 图论算法

### 状态空间线
![alt txt](https://raw.githubusercontent.com/corykingsf/hack-interview-handboook-pixel/main/imgSnipaste_2021-06-21_23-05-11.png)


### 两个副本
- 顺序优化副本: 排序、二分
- 高级数据结构副本：平衡树、跳表、树状数组、线段树

## 为什么 vs 怎么想到
- 情景引入,分析use case --> 问题模型化(解决一套模型而不是一个题目) --> 知识点 --> 实战题目(讲思路的形成过程，代码落地,如何写得又快又对,如何让代码结构简洁易懂，如何模块化处理细节, 如何预判避免错误)

### 代码主结构简单易懂，模块化处理细节

### 训练时间
![alt txt](https://raw.githubusercontent.com/corykingsf/hack-interview-handboook-pixel/main/imgSnipaste_2021-06-21_23-13-37.png)


### 听课的方法
课前预习
- 浏览ppt, 标注自己完全不懂的地方
- 每个只是点选一道立体，看看题意，大致想想

课上听讲:
- 紧跟老师的大思考方向，不要太拘泥于细节的证明，可以之后在回放
- 承认算法和数据结果的复杂性，课上之听懂60%-70%是正常的额

课后回顾:
- 不要1.0倍整体播放，只需要回访重点，不理解的地方，或者1.5-2.0倍速回放
- 自己举例实践老师讲的算法，有时间及时提问

### 算法学习的误区
- 误区1 对待题解的两个极端
  - 看题解刷题 - 看似速度快，做的提多，实际上抛开题解大脑一片空白
  - 坚决不看题解，自己死扣- 陷入自己原有的思路里，学不到高票题解，高票代码的优秀思路
  
误区2 - Leetcoe每题只做一遍或者leetcode随机刷综合题
正确做法: 坚持分类三刷

误区3： 面对一道题，拿学过的算法挨个试解
- 正确做法： 坚持五步刷题，剖析题目关键点->回想学过的模型->根据特征找到算法，题目特征驱动算法，而不是猜测算法试解题目

知识点：
- 基本技能
- 时间、空间复杂度分析
- 面试中的程序调试与测试
- 位运算
- 线性数据结构及相关算法
- 数组、链表、栈
- 哈希表、集合、映射
- 前缀和、差分
- 双指针扫描、滑动窗口
- 树形数据结构及相关算法
- 递归、分治
- 树、二叉树、二叉搜索树
 - 堆
- 字典树
- 并查集
- 跳跃表
- 平衡二叉树
- 树状数组、线段树
- 搜索
- 深度优先搜索
- 广度优先搜索
- 动态规划
- 线性动态规划
- 树形动态规划
- 图论
- 最短路
- 最小生成树
- 字符串处理
- 模式匹配
- 字符串哈希
- 二分
- 排序
- 贪心


![alt txt](https://raw.githubusercontent.com/corykingsf/hack-system-design-pixel/main/imgSnipaste_2021-06-22_22-05-45.png)

![alt txt](https://raw.githubusercontent.com/corykingsf/hack-system-design-pixel/main/imgSnipaste_2021-06-22_22-06-53.png)


![alt txt](https://raw.githubusercontent.com/corykingsf/hack-system-design-pixel/main/imgSnipaste_2021-06-22_22-07-24.png)


![alt txt](https://raw.githubusercontent.com/corykingsf/hack-system-design-pixel/main/imgSnipaste_2021-06-22_22-07-55.png)

![alt txt](https://raw.githubusercontent.com/corykingsf/hack-system-design-pixel/main/imgSnipaste_2021-06-22_22-08-32.png)


![alt txt](https://raw.githubusercontent.com/corykingsf/hack-system-design-pixel/main/imgSnipaste_2021-06-22_22-08-43.png)