- 有些问题不以并查集为背景，但的确可以使用并查集的知识帮助我们解决问题。由于等式相等具有传递性，比较容易想到使用并查集。

- 1、扫描所有等式，将等式两边的顶点进行合并；

- 2、再扫描所有不等式，检查每一个不等式的两个顶点是不是在一个连通分量里，如果在，则返回 false 表示等式方程有矛盾。如果所有检查都没有矛盾，返回 true。

- 所有相等的元素放到一个集合里，如果a == q, 那么a和q所属的集合可以合并

- 然后看所有不等的元素，如果两个不等的元素在同一个集合里一定

- 我使用的策略是这样的（仅供参考）：用「隔代压缩」，代码比较好写。不写「按秩合并」，除非题目有一些关于「秩」的信息需要讨论。一般来说，这样写也能得到不错的性能，如果性能不太好的话，再考虑「按秩合并」。


```
并查集知识小结：

1、解决的是两个顶点是否连通的问题，可以用于检测图中是否存在环；

2、代表元法：采用 parent 数组实现，以每个结点的根结点作为代表元；

3、并查集的优化有两种策略：

（1）路径压缩；

有「隔代压缩」与「完全压缩」。

● 「隔代压缩」性能比较高，虽然压缩不完全，不过多次执行「隔代压缩」也能达到「完全压缩」的效果，我本人比较偏向使用「隔代压缩」的写法。
● 「完全压缩」需要借助系统栈，使用递归的写法。或者先找到当前结点的根结点，然后把沿途上所有的结点都指向根结点，得遍历两次。

（2）按秩合并。

秩也有两种含义：

● 秩表示以当前结点为根结点的子树结点总数，即这里的「秩」表示 size 含义；
● 秩表示以当前结点为根结点的子树的高度，即这里的「秩」表示 rank 含义（更合理，因为查询时候的时间性能主要决定于树的高度）。

4、如果同时使用「路径压缩」与「按秩合并」，这里的「秩」就失去了它的定义，但即使秩表示的含义不准确，也能够作为合并时候很好的「参考」。在这种情况下，并查集的查询与合并的时间复杂度可以达到接近

```

```java
class Solution {
    // 存储所有元素的分组信息
    int[] p;
    public boolean equationsPossible(String[] equations) {
        p = new int[26];
      //assume一共26个小写字母，每个字母的group信息初始设置为自己
     for (int i = 0; i <26; i++) p[i] = i;
     //枚举所有相等关系   
     for (String e :equations) {
         char[] arr = e.toCharArray();
         int a = arr[0] - 'a', b = arr[3] - 'a';
         if (arr[1] == '=') p[find(a)] = find(b);
     }   
     //枚举所有不等关系 
     for (String e :equations) {
         char[] arr = e.toCharArray();
       
         int a = arr[0] - 'a', b = arr[3] - 'a';
         if (arr[1] == '!') {
             if (find(a) == find(b)) return false;
         }
     }
     return true;   
    }
    private int find(int x) {  // quick find
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
   
}
```
