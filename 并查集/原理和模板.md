并查集是一种建立在「数组」上的树形结构，并且这棵树的特点是孩子结点指向父亲结点
-
「并查集」主要用于解决「动态连通性」问题，重点关注的是连接问题，并不关注路径问题；
-

并查集」是树，所以优化的策略依然是和树的高度较劲，优化思路有「按秩合并」与「路径压缩」。
-

### 动态判断图的连通性

* 堆的作用：在数据动态变化的情况下用最优的时间拿出max/min

1. 并查集： 孩子指向父亲形成的一种树结构,用来解决连接问题
2. 


* 并查集用来解决connectivity problem
* 给出图中两点，判断两点是否可以经由一条路径连接

* 非常快的判断网络中节点间的连接状态
* 并查集也是集合这一概念在数据结构中的实现，可以高效求并集

### 基于size的优化和基于rank的优化



### 连接问题和路径问题

* 如果我们只想知道a， b两点的连接状态，我们通过求解路径问题来知道连接状态其实消耗了额外的性能


并查集支持的操作：

union(p,q)

isConnected(p,q)  --> find(p) == find(q)  //find返回的是元素的group的ID


并查集可以有不同的底层实现


并查集接口:


```java
public interface UF {
    int getSize();
    boolean isConnected(int p, int q);
    void unionElements(int p, int q);
}
```

```java
public interface IUnionFind {

    // 并查集的版本名称，由开发者指定
    String versionName();

    // p (0 到 N-1)所在的分量的标识符
    int find(int p);

    // 如果 p 和 q 存在于同一分量中则返回 true
    boolean isConnected(int p, int q);

    // 在 p 与 q 之间添加一条连接
    void union(int p, int q);

}
```

使用ID数组来存储每个元素所属的集合是谁
-


quick find下的find() 时间是O(1), union的时间是O(n)

并查集第1版(quick-find实现)
-

```java
public class UnionFind1 implements IUnionFind {

    private int[] id; // 分量 id

    private int count; // 连通分量的数量

    public UnionFind1(int n) {
        this.count = n;
        // 初始化分量 id 数组
        id = new int[n];
        for (int i = 0; i < n; i++) {
            id[i] = i;
        }
    }

    @Override
    public String versionName() {
        return "并查集的第 1 个版本，基于 id 数组，quick-find";
    }

    // 以常数时间复杂度，返回分量的标识符，与并查集的规模是无关的，这一步很快
    // 因此我们称这个版本的并查集是 quick-find
    @Override
    public int find(int p) {
        return id[p];
    }

    @Override
    public boolean isConnected(int p, int q) {
        return find(p) == find(q);
    }

    // 因为需要遍历数组中的全部元素，所以这个版本其实效率并不高
    @Override
    public void union(int p, int q) {
        int pid = find(p);
        int qid = find(q);

        // 如果 p 和 q 已经在相同的分量之中，则什么都不做
        if (pid == qid) {
            return;
        }

        // 将 p 的分量重新命名为 q 的名称
        for (int i = 0; i < id.length; i++) {
            if (find(i) == pid) {
                id[i] = qid;
            }
        }
        // 每次 union 以后，连通分量减 1
        count--;
    }
}
```


并查集第2版(基于parent的并查集,非最终版本). quick-union
-

```
这一版「并查集」代码是最基本的「并查集」，我们需要学习思想，核心思想是「代表元法」，以「树」的「根结点」作为代表元。
后续我们介绍这一版代码的两个优化：
1、按秩合并（有 2 个版本）
2、路径压缩（有 2 个版本）
介绍得多，只是为了方便大家建立知识结构，真正我们只会使用一个版本的「并查集」。我们放在介绍完了以后再说。
```

```java
public class UnionFind2 implements IUnionFind {

    private int[] parent; // 第 i 个元素存放它的父元素的索引

    private int count; // 连通分量的数量

    public UnionFind2(int n) {
        this.count = n;
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;   //初始化时每个元素的父亲都是自己
        }
    }
    public String versionName() {
        return "并查集的第 2 个版本，基于 parent 数组，quick-union";
    }
    public int find(int p) {
        // 跟随链接找到根结点
        while (parent[p] != p) { // 只要不是根结点,就继续找父亲，只要找到为止
            p = parent[p];
        }
        return p;
    }
    public boolean isConnected(int p, int q) {
        return find(p) == find(q);
    }

    // union两个节点，把其中一个节点的根节点指向另一个节点的根节点就可以了
    public void union(int p, int q) {
        int pRoot = find(p); // 将 p 归并与之相同的分量中
        int qRoot = find(q); // 将 q 归并与之相同的分量中

        // 如果 p 和 q 已经在相同的分量之中，则什么都不做
        if (pRoot == qRoot) {
            return;
        }
        // 如果 parent[qRoot] = pRoot; 也是可以的，即将其中一个结点指向另一个结点
        parent[pRoot] = qRoot;
        // 每次 union 以后，连通分量减 1
        count--;
    }
}
```

并查集第3版(quikc-union基于size的优化)
-

```
这一版「并查集」代码是最基本的「并查集」，我们需要学习思想，核心思想是「代表元法」，以「树」的「根结点」作为代表元。
后续我们介绍这一版代码的两个优化：
1、按秩合并（有 2 个版本）
2、路径压缩（有 2 个版本）
介绍得多，只是为了方便大家建立知识结构，真正我们只会使用一个版本的「并查集」。我们放在介绍完了以后再说。
我们发现 union(4, 9) 与 union(9, 4) 其实是一样的，也就是把谁的根指向谁的根，这一点从正确性上来说是无关紧要的，但是对于 find 的时间复杂度就会有影响。为此，我们做如下优化。
在合并之前做判断，具体做法是，计算每一个结点有多少个元素直接或者间接地以它为根，我们应该将集合元素少的那结点的根指向集合元素多的那个结点的根。这样，形成的树就会更高概率地形成一棵层数较低的树。
为此，我们再引入一个 size 数组，size[i] 的定义是：以第 i 个结点为根的集合的元素的个数。
在初始化的时候 size[i] = 1，find 和 isConnected 操作中我们都不须要去维护 size 这个数组，唯独在 unionElements 的时候，我们才要维护 size 数组的定义。
```

```java
// union-find 算法的实现（加权 quick-union 算法）
public class UnionFind3 implements IUnionFind {

    private int[] parent; // 第 i 个元素存放它的父元素的索引

    private int count; // 连通分量的数量

    private int[] size; // 以当前索引为根的树所包含的元素的总数

    public UnionFind3(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            // 初始化时，所有的元素只包含它自己，只有一个元素，所以 size[i] = 1
            size[i] = 1;
        }
    }
    public String versionName() {
        return "并查集的第 3 个版本，基于 parent 数组，quick-union，基于 size";
    }
    // 返回索引为 p 的元素的根结点的索引
    public int find(int p) {
        // 跟随链接找到根结点
        while (p != parent[p]) {
            p = parent[p];
        }
        return p;
    }
    public boolean isConnected(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        return pRoot == qRoot;
    }
    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if (pRoot == qRoot) {
            return;
        }
        // 这一步是与第 2 版不同的地方，我们不是没有根据地把一个结点的根结点的父结点指向另一个结点的根结点
        // 而是将小树的根结点连接到大树的根结点
        if (size[pRoot] > size[qRoot]) {
            parent[qRoot] = pRoot;
            size[pRoot] += size[qRoot];
        } else {
            parent[pRoot] = qRoot;
            size[qRoot] += size[pRoot];
        }
        // 每次 union 以后，连通分量减 1
        count--;
    }
}
```
并查集第4版(quikc-union基于rank的优化)


```java
public class UnionFind4 implements IUnionFind {

    private int[] parent;

    private int count;

    // 以下标为 i 的元素为根结点的树的深度（最深的那个深度）
    private int[] rank;

    public UnionFind4(int n) {
        this.count = n;
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            // 初始化时，所有的元素只包含它自己，只有一个元素，所以 rank[i] = 1
            rank[i] = 1;
        }
    }
    public String versionName() {
        return "并查集的第 4 个版本，基于 parent 数组，quick-union，基于 rank";
    }

    // 返回下标为 p 的元素的根结点
    public int find(int p) {
        while (p != parent[p]) {
            p = parent[p];
        }
        return p;
    }
    public boolean isConnected(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        return pRoot == qRoot;
    }
    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if (pRoot == qRoot) {
            return;
        }
        // 这一步是与第 3 版不同的地方
        if (rank[pRoot] > rank[qRoot]) {
            parent[qRoot] = pRoot;
        } else if (rank[pRoot] < rank[qRoot]) {
            parent[pRoot] = qRoot;
        } else {
            parent[qRoot] = pRoot;
            rank[pRoot]++;
        }
        // 每次 union 以后，连通分量减 1
        count--;
    }
}
```


并查集第5版quick-union基于路径压缩的非递归实现
-

```
这一版代码用得最多。因为好理解，且代码量较少。
只用理解这一句即可 parent[p] = parent[parent[p]];，可以称之为「隔代压缩」。
虽然压缩不彻底，但是多压缩几次也就能够达到完全压缩的效果，且不使用递归，占用「递归栈」空间。

什么是路径压缩 path Compression？以上我们都是针对于 union 操作的优化，其实我们在 find 的时候，就可以对一棵树进行整理，让它的高度变低，这一点是基于并查集的一个特性：只要它们是连在一起的，其实谁指向谁，并不重要，所以我们在接下来的讨论中看到的并查集的表示图，它们是等价的，即它们表示的都是同一个并查集。

```
![picture 2](https://i.loli.net/2021/10/18/mjxDwV6yPsYcvBq.png)  



| 状态 | 题目                           | 通过率   | 难度 | 出现频率 |
|----|------------------------------|-------|----|------|
|    | 128. 最长连续序列                  | 54.3% | 中等 |      |
|    | 130. 被围绕的区域                  | 44.4% | 中等 |      |
|    | 200. 岛屿数量                    | 55.4% | 中等 |      |
|    | 261. 以图判树                    | 49.5% | 中等 |      |
|    | 305. 岛屿数量 II                 | 37.9% | 困难 |      |
|    | 323. 无向图中连通分量的数目             | 63.2% | 中等 |      |
|    | 399. 除法求值                    | 59.3% | 中等 |      |
|    | 547. 省份数量                    | 61.8% | 中等 |      |
|    | 684. 冗余连接                    | 66.6% | 中等 |      |
|    | 685. 冗余连接 II                 | 43.2% | 困难 |      |
|    | 694. 不同岛屿的数量                 | 53.1% | 中等 |      |
|    | 695. 岛屿的最大面积                 | 66.3% | 中等 |      |
|    | 711. 不同岛屿的数量 II              | 57.3% | 困难 |      |
|    | 721. 账户合并                    | 46.9% | 中等 |      |
|    | 737. 句子相似性 II                | 46.1% | 中等 |      |
|    | 765. 情侣牵手                    | 66.5% | 困难 |      |
|    | 778. 水位上升的泳池中游泳              | 59.6% | 困难 |      |
|    | 785. 判断二分图                   | 51.2% | 中等 |      |
|    | 803. 打砖块                     | 48.3% | 困难 |      |
|    | 827. 最大人工岛                   | 39.1% | 困难 |      |
|    | 839. 相似字符串组                  | 57.5% | 困难 |      |
|    | 886. 可能的二分法                  | 42.4% | 中等 |      |
|    | 924. 尽量减少恶意软件的传播             | 36.0% | 困难 |      |
|    | 928. 尽量减少恶意软件的传播 II          | 42.0% | 困难 |      |
|    | 947. 移除最多的同行或同列石头            | 61.3% | 中等 |      |
|    | 952. 按公因数计算最大组件大小            | 35.0% | 困难 |      |
|    | 959. 由斜杠划分区域                 | 74.3% | 中等 |      |
|    | 990. 等式方程的可满足性               | 50.2% | 中等 |      |
|    | 1061. 按字典序排列最小的等效字符串         | 60.2% | 中等 |      |
|    | 1020. 飞地的数量                  | 53.6% | 中等 |      |
|    | 1101. 彼此熟识的最早时间              | 66.9% | 中等 |      |
|    | 1102. 得分最高的路径                | 36.8% | 中等 |      |
|    | 1135. 最低成本联通所有城市             | 53.4% | 中等 |      |
|    | 1168. 水资源分配优化                | 57.2% | 困难 |      |
|    | 1258. 近义词句子                  | 55.9% | 中等 |      |
|    | 1627. 带阈值的图连通性               | 37.9% | 困难 |      |
|    | 1632. 矩阵转换后的秩                | 31.8% | 困难 |      |
|    | 1361. 验证二叉树                  | 40.1% | 中等 |      |
|    | 1202. 交换字符串中的元素              | 50.3% | 中等 |      |
|    | 1254. 统计封闭岛屿的数目              | 59.8% | 中等 |      |
|    | 1267. 统计参与通信的服务器             | 60.8% | 中等 |      |
|    | 1319. 连通网络的操作次数              | 61.7% | 中等 |      |
|    | 1391. 检查网格中是否存在有效路径          | 40.1% | 中等 |      |
|    | 1489. 找到最小生成树里的关键边和伪关键边      | 69.2% | 困难 |      |
|    | 1559. 二维网格图中探测环              | 36.7% | 困难 |      |
|    | 1569. 将子数组重新排序得到同一个二叉查找树的方案数 | 47.2% | 困难 |      |
|    | 1579. 保证图可完全遍历               | 62.0% | 困难 |      |
|    | 1584. 连接所有点的最小费用             | 66.6% | 中等 |      |
|    | 1631. 最小体力消耗路径               | 49.3% | 中等 |      |
|    | 1697. 检查边长度限制的路径是否存在         | 52.6% | 困难 |      |
