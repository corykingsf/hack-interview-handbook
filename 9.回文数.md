### palindrome优化：可以只翻转一半。稍微省一些时间，但是并没有影响时间复杂度


```java
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0 || x && x % 10 == 0) return false;
        int s = 0;
        while (s <= x)
        {
            s = s * 10 + x % 10;
            if (s == x || s == x / 10) return true; // 分别处理整数长度是奇数或者偶数的情况
            x /= 10;
        }
        return false;
    }
};


```

- solution 1: 转成字符串比较好做

```java
class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0) return false;
        
        String s = String.valueOf(x);
        
        return reverse(s).equals(s);
    }
    private String reverse(String s) {
        char[] arr = s.toCharArray();
        int left = 0;
        int right = s.length() - 1;
        
        while (left < right) {
            char c = arr[left];
            arr[left] = arr[right];
            arr[right] = c;
            
            left++;
            right--;
        }
        return new String(arr);
    }
}
```

- solution 2:  负数直接返回false


```java
class Solution {
    public boolean isPalindrome(int x) {
        // 利用reverse integer那个题的代码直接反转integer
        
        if (x < 0) return false;
        
        long revertInt = reverse(x);
        
        
        return (int)revertInt == x;
    }
    private long reverse(int x) {
        long ret = 0;
        
        while (x != 0) {
            ret = ret * 10 + x % 10;
            x = x / 10;
        }
        return ret;
    }
}
```