
马拉车算法专门用来解决回文算法


这个题可以用字符串哈希来做，palindrome的正着hash和反着hash是一样的



方法1： dynamic programming


方法2： 暴力比较，n^3


方法3： 暴力枚举，比较字符串哈希


方法4： 枚举中点，开始向两边扩展
中心扩散法
「中心扩散法」的基本思想是：遍历每一个下标，以这个下标为中心，利用「回文串」中心对称的特点，往两边扩散，看最多能扩散多远。

枚举「中心位置」时间复杂度为 O(N)O(N)，从「中心位置」扩散得到「回文子串」的时间复杂度为 O(N)O(N)，因此时间复杂度可以降到 O(N^2)O(N 
2
 )。

细节：回文串在长度为奇数和偶数的时候，「回文中心」的形态不一样：

奇数回文串的「中心」是一个具体的字符，例如：回文串 "aba" 的中心是字符 "b"；
偶数回文串的「中心」是位于中间的两个字符的「空隙」，例如：回文串 "abba" 的中心是两个 "b"，也可以看成两个 "b" 中间的空隙。

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        if (s.empty()) return "";
        int n = s.length();
        s = " " + s;
        int anslen = 0;
        int ansstart = 0;
        // 中心是一个字符，比如aba
        for (int center = 1; center <= n; center++) {
            int l = center - 1;
            int r = center + 1;
            while (l > 0 && r <= n && s[l] == s[r]) {
                l--; r++;
            }
            // l+1~r-1
            if (r - l - 1 > anslen) {
                anslen = r - l - 1;
                ansstart = l + 1;
            }
        }
        // 中心是两个字符（一个空档），比如abba
        for (int center = 1; center < n; center++) {
            int l = center;
            int r = center + 1;
            while (l > 0 && r <= n && s[l] == s[r]) {
                l--; r++;
            }
            // l+1~r-1
            if (r - l - 1 > anslen) {
                anslen = r - l - 1;
                ansstart = l + 1;
            }
        }
        return s.substr(ansstart, anslen);
    }
};
```