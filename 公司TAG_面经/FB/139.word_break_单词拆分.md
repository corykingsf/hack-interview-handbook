dfs
-

```
"leetcode"能否 break，可以拆分为：
"l"是否是单词表的单词、剩余子串能否 break。
"le"是否是单词表的单词、剩余子串能否 break。
"lee"...以此类推
用 DFS 回溯，考察所有的拆分可能，指针从左往右扫描：
如果指针的左侧部分是单词，则对剩余子串递归考察。
如果指针的左侧部分不是单词，不用看了，回溯，考察别的分支。
我画出递归树，即问题的解的空间树：
```
![20211123000459](https://raw.githubusercontent.com/corykingsf/hack-interview-handbook/main/image/20211123000459.png)




```
base case
base case 为dp[0] = true。即，长度为 0 的s[0:-1]能拆分成单词表单词。
这看似荒谬，但这只是为了让边界情况也能套用状态转移方程，而已。
当 j = 0 时（上图黄色前缀串为空串），s[0:i]的dp[i+1]，取决于s[0:-1]的dp[0]，和，剩余子串s[0:i]是否是单个单词。
只有让dp[0]为真，dp[i+1]才会只取决于s[0:i]是否为单个单词，才能用上这个状态转移方程。

```