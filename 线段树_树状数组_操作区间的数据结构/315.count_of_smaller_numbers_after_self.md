
计算右侧小于当前元素的个数的六种方法：


这道题要用排序的思路来解决。快速查找和更新，使用递归或树的结构可以高效实现。


1.暴力模拟法，每次都从末尾找比nums[i]小的数并计数，然后放到结果数组即可.时间复杂度: O(n^2),leetcode上超时了

```java
    public List<Integer> countSmaller(int[] nums) {
        // sanity check
        List<Integer> smallerThanSelf = new ArrayList<>();

        for (int i = 0 ; i < nums.length - 1; i++) {
            int count = 0;
            for (int j = i +1; j < nums.length; j++) {
                if (nums[j] < nums[i]) {
                    count++;
                }
            }
            smallerThanSelf.add(count);
        }
        smallerThanSelf.add(0);
        return smallerThanSelf;
    }
```

2.插入排序 
从右往左插入排序，根据插入的位置计算右边小于当前元素的个数
优化：先使用二分查找位置，在插入，可以降低内层循环查找的时间复杂度O(nlogn),但是元素交换的次数还是O(^2)

3.记忆化+排序


solution 4 树状数组


- 从右向左看


//1.某个位置加上一个数
//2.求1~x的和

求比x小的数的个数其实就是求11~(x-1)的数的个数 （假设所有数从1开始），在树上query一下(x-1)即可

```java
class Solution {
    private class FenwickTree {
        private int[] tree;
        private int len;

        public FenwickTree(int n) {
            this.len = n;
            tree = new int[n + 1];
        }
        // 单点更新：将 index 这个位置 + 1
        public void update(int i, int delta) {
            // 从下到上，最多到 size，可以等于 size
            while (i <= this.len) {
                tree[i] += delta;
                i += lowbit(i);
            }
        }
        // 区间查询：查询小于等于 index 的元素个数
        // 查询的语义是"前缀和"
        public int query(int i) {
            // 从右到左查询
            int sum = 0;
            while (i > 0) {
                sum += tree[i];
                i -= lowbit(i);
            }
            return sum;
        }
        public int lowbit(int x) {
            return x & (-x);
        }
    }
    public List<Integer> countSmaller(int[] nums) {
        List<Integer> ret = new ArrayList<>();
        int len = nums.length;
        if (len == 0) return ret;
        
        // 使用二分搜索树方便排序，对原数组里的元素进行排名(离散化)
        Set<Integer> set = new TreeSet<>();
        for (int i = 0; i < nums.length; i++) {
            set.add(nums[i]);
        }
        
        // 做排名表
        Map<Integer, Integer> map = new HashMap<>();
        int rank = 1;
        for (Integer num : set) {    //遍历treeset,按从小到大的顺序把元素一次放进map， key:元素， value:排名
            map.put(num, rank);
            rank++;
        }
        FenwickTree ft = new FenwickTree(set.size() + 1);  // fenwick tree下标从1开始
        // 从后向前填表
        for (int i = len - 1; i >= 0; i--) {
            // 1、查询排名
            rank = map.get(nums[i]);
            // 2、在树状数组排名的那个位置 + 1
            ft.update(rank, 1);
            // 3、查询一下小于等于“当前排名 - 1”的元素有多少
            ret.add(ft.query(rank - 1));
        }
        Collections.reverse(ret);
        return ret;
    }
}
```




