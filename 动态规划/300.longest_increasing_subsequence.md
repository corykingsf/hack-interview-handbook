分析过程：

### brute force (搜索)-->  pure recursion ->dp

### brute force:

![alt txt](https://raw.githubusercontent.com/corykingsf/hack-system-design-pixel/main/imgSnipaste_2021-06-24_20-40-56.png)



### 搜索：

```java
//backtracking approach
int‌‌ globalMax‌‌ = ‌‌1;‌‌
public‌‌ void‌‌ longest(int[]‌‌ array, ‌‌int‌‌ index)‌‌ {‌‌
	List<Integer> ‌‌curPath‌‌ = ‌‌new‌‌ ArrayList<>();‌‌
	curPath.add(array[index]);‌‌
	dfs(array, ‌‌index, ‌‌‌curPath‌‌‌→‌‌ 1);‌‌
	curPath.remove(curPath.size()‌‌ - ‌‌1);‌‌
	return‌‌ globalMax;‌‌
}‌‌
//‌ ‌find‌ ‌all‌ ‌increasing‌ ‌sequence‌ ‌
public‌‌ void‌‌ dfs(int[]‌‌ array, ‌‌int‌‌ index, ‌‌‌List<Integer> ‌‌curPath‌‌‌→‌‌‌ int‌‌ size‌)‌‌ {‌‌‌ //‌ ‌当‌前‌subsequence‌的‌长‌度‌ ‌
	//‌ ‌implicit‌ ‌base‌ ‌case‌ ‌
	//先写all branches
	globalMax‌‌ = ‌‌Math.max(‌curPath.size()‌‌‌→‌‌ size, ‌‌globalMax);‌‌‌
	for‌‌(int‌‌ i‌‌ = ‌‌index‌‌ - ‌‌1;‌‌ i‌‌ >= ‌‌0;‌‌ i--)‌‌ {‌‌ //‌ ‌当‌前‌这‌一‌层‌做‌什‌么？‌分‌解‌所‌有‌解‌的‌一‌种‌方‌法‌ ‌
		if‌‌(array[i]‌‌<‌‌array[index])‌‌ {‌‌
			curPath.add(array[i]);‌‌
			dfs(array, ‌‌i, ‌‌‌curPath‌‌‌→‌‌ size‌‌‌ + ‌‌1‌);‌‌
			curPath.remove(curPath.size()‌‌ - ‌‌1);‌‌
		}‌‌
	}‌‌
}‌‌

Time: ‌‌O(2 ^ n)‌‌
```

### 只用求长度，所以不用传整条Path下去:


```java
//‌ ‌find‌ ‌all‌ ‌increasing‌ ‌sequence‌ ‌
//‌ ‌definition:‌ ‌ending‌ ‌at‌ ‌index‌，‌最‌长‌的‌increasing‌ ‌subsequence‌长‌度‌是‌多‌少？‌  ‌subarray[0,‌ ‌index]‌ ‌
public‌‌ int‌‌ longest(int[]‌‌ array, ‌‌int‌‌ index, ‌‌‌List<Integer> ‌‌curPath‌‌→‌‌ int‌‌ size‌)‌‌ {‌‌‌ //‌ ‌pure‌ ‌recursion‌ ‌
	//‌ ‌implicit‌ ‌base‌ ‌case‌ ‌
	int‌‌ max‌‌ = ‌‌1;‌‌‌
	for‌‌(int‌‌ i‌‌ = ‌‌index‌‌ - ‌‌1;‌‌ i‌‌ >= ‌‌0;‌‌ i--)‌‌ {‌‌ //‌ ‌当‌前‌这‌一‌层‌做‌什‌么？‌分‌解‌所‌有‌解‌的‌一‌种‌方‌法‌ ，for.loop根本不变
		if‌‌(array[i]‌‌<‌‌array[index])‌‌ {‌‌
			curPath.add(array[i]);‌‌
			max‌‌ = ‌‌Math.max(max, ‌‌longest(array, ‌‌i)‌‌‌ + ‌‌1‌);‌‌
			curPath.remove(curPath.size()‌‌ - ‌‌1);‌‌
		}‌‌
	}‌‌
	return‌‌ max;‌‌
}‌‌‌
```

### pure recursion:


```java
//‌ ‌find‌ ‌all‌ ‌increasing‌ ‌sequence‌ ‌
//‌ ‌definition:‌ ‌ending‌ ‌at‌ ‌index‌，‌最‌长‌的‌increasing‌ ‌subsequence‌长‌度‌是‌多‌少？‌  ‌subarray[0,‌ ‌index]‌ ‌ //dp’s definition
public‌‌ int‌‌ longest(int[]‌‌ array, ‌‌int‌‌ index, ‌‌‌List<Integer> ‌‌curPath‌‌→‌‌ int‌‌ size‌)‌‌ {‌‌‌ //‌ ‌pure‌ ‌recursion‌ ‌
	//‌ ‌implicit‌ ‌base‌ ‌case‌ ‌
	int‌‌ max‌ = ‌‌1;‌‌‌
	for‌‌(int‌‌ i‌‌ = ‌‌index‌‌ - ‌‌1;‌‌ i‌‌ >= ‌‌0;‌‌ i--)‌‌ {‌‌ //‌ ‌当‌前‌这‌一‌层‌做‌什‌么？‌分‌解‌所‌有‌解‌的‌一‌种‌方‌法‌,induction rule控制recursion true ‌
		if‌‌(array[i]‌‌<‌‌array[index])‌‌ {‌‌
			curPath.add(array[i]);‌‌
			max‌‌ = ‌‌Math.max(max, ‌‌longest(array, ‌‌i)‌‌‌ + ‌‌1‌);‌‌‌ //dp’s induction
			//‌ ‌index‌必‌须‌放‌到‌increasing‌ ‌subsequence‌里‌面‌ ‌
			curPath.remove(curPath.size()‌‌ - ‌‌1);‌‌
		}‌‌
	}‌‌
	return‌‌ max;‌‌
}‌‌‌
```