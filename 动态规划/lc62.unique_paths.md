

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || j == 0) dp[i][j] = 1;
                else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}
```


```java
//对于强迫症来说，多增加一行和一列可以减少很多的判断
    public int uniquePaths(int m, int n) {
        int[][] f = new int[m + 1][n + 1];
        //下面这两个都可以
        f[0][1] = 1;
    //    f[1][0] = 1;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                f[i][j] = f[i - 1][j] + f[i][j - 1];
            }
        }
        return f[m][n];
    }


```

* 1. 我们是如何确定本题可以使用动态规划来解决的？

* 通常我们要从「有无后效性」进行入手分析。

* 如果对于某个状态，我们可以只关注状态的值，而不需要关注状态是如何转移过来的话，那么这就是一个无后效性的问题，可以考虑使用 DP 解决。

* 另外一个更加实在的技巧，我们还可以通过 数据范围 来猜测是不是可以用 DP 来做。

* 因为 DP 是一个递推的过程，因此如果数据范围是 10^5 ~ 10^6 的话，可以考虑是不是可以使用一维 DP 来解决；如果数据范围是 10^2 ~ 10^3的话，可以考虑是不是可以使用二维 DP 来做 ...

* 2. 我们是如何确定本题的状态定义的？

* 说实话，DP 的状态定义很大程度是靠经验去猜的。

* 虽然大多数情况都是猜的，但也不是毫无规律，相当一部分题目的状态定义是与「结尾」或「答案」有所关联的。

* 3. 我们是如何确定状态转移方程的？

* 通常来说，如果我们的状态定义猜对了，状态转移方程就是对「最后一步的分情况讨论」。

* 如果我们有一个对的状态定义的话，基本上状态转移方程就是呼之欲出。

* 因此一定程度上，状态转移方程可以反过来验证我们状态定义猜得是否正确：

* 如果猜了一个状态定义，然后发现无法列出涵盖所有情况（不漏）的状态转移方程，多半就是状态定义猜错了，赶紧换个思路，而不是去死磕状态转移方程。

* 4. 对状态转移的要求是什么？

* 我们的状态转移是要做到「不漏」还是「不重不漏」取决于问题本身：

* 如果是求最值的话，我们只需要确保「不漏」即可，因为重复不影响结果。
* 如果是求方案数的话，我们需要确保「不重不漏」。

5. 我们是如何分析动态规划的时间复杂度的？

对于动态规划的复杂度/计算量分析，有多少个状态，复杂度/计算量就是多少。

因此一维 DP 的复杂度通常是线性的 O(n)O(n)，而二维 DP 的复杂度通常是平方的 O(n^2)
