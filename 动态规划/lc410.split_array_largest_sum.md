




https://leetcode-cn.com/problems/split-array-largest-sum/solution/er-fen-cha-zhao-by-liweiwei1419-4/

```
写在前面的话：

动态规划的写法其实是穷举：按照长度、前缀，枚举最后一个划分，记录每一步结果。细节比较多，需要作图 + 仔细讨论边界情况，并且熟悉二维状态数组、三层 for 循环的写法；
本题的二分查找的思路来源于二分查找的基本思想（应用）：查找一个有范围的整数，关键在于利用单调性逼近这个整数。「力扣」上很多问题都基于本题设计，属于「使用二分查找最大值最小化」的一类问题的例题。
题意分析：各自和的最大值最小，这句话读起来有一点点绕。我们拆分一下：

由于数组是确定的，其中一组分得多，相应地另一组分到的值就少。所以对于任意一种拆分（切成 m 段），这 m 段可以取最大值 val；
我们需要找到一种拆分，使得这个最大值 val 的值是所有分成 m 段拆分里值最小的那个；具体怎么拆，题目不用我们求，只需要我们计算出 val 的值。
方法一：动态规划
枚举所有的分割的情况，例如题目中的输入数组 [7, 2, 5, 10, 8] 分割成 22 个非空连续子数组，可以有以下 44 种方式：

[7, | 2, 5, 10, 8]；
[7, 2, | 5, 10, 8]；
[7, 2, 5, | 10, 8]；
[7, 2, 5, 10, | 8]。
比较容易想到的递归结构是：

找到最后一个分割，求出这个分割的连续子数组的和，与之前的分割取最大值；
枚举最后一个分割，找出所有最大值中最小的那一个。


```


解法1： binary search

```java
class Solution {
    public int splitArray(int[] nums, int m) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int max = 0;
        long sum = 0;
        for (int num : nums) {
            max = Math.max(max, num);
            sum += num;
        }
        if (m == nums.length) {
            return max;
        }
        if (m == 1){
            return (int)sum;
        }
        long left = max;
        long right = sum;
        while (left < right) {
            long mid = left + (right - left) / 2;
            if (canSplit(nums, m, mid)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return (int)right;
    }
    private boolean canSplit(int[] nums, int m, long max) {
        int count = 1;
        int cur = 0;
        for (int num : nums) {
            cur += num;
            if (cur > max) {
                cur = num;
                count++;
                if (count > m) {
                    return false;
                }
            }
        }
        return true;
    }
}
```



解法2：  dp
s1: start from brute force
     --> 所有解 = 所有的切法  -> 把整个array分成m段所有的分割方法
     --> 特征值 = 所有切法里面,切的次数最小的
                        
                        特征值
     [7,    2,5,10, 8]  largest sum = 25

     [7,2,    5,10, 8]  largest sum = 23
     [7,2,5,    10, 8]  largest sum = 18
     [7,2,5,10, 8]      largest sum = 24
   

min是针对所有的切法来说的,max是针对当前切法的最大的subarray sum

